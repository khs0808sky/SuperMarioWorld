#pragma once
// 이 헤더엔 앞으로 상수 버퍼가 새로운 종류로서 필요할 때마다 클래스를 새로이 선언하여 추가할 예정
// = 상수 버퍼는 종류가 매우 다양하다보니 필요할 때마다 이 헤더에 정의


class MatrixBuffer : public ConstBuffer
// WVP 변환 등, 행렬이 저장된 버퍼가 필요한 상황에 사용하는 상수 버퍼
{
private:
	struct Data
	{
		Matrix matrix;
	} data;

public:
	MatrixBuffer() : ConstBuffer(&data, sizeof(data))
	{
		data.matrix = XMMatrixIdentity();
		// 단위행렬을 만들어주는 함수
		/*
		행렬의 곱셈방식에 대한 설명은 생략
		여튼, 행렬의 곱셈 방식을 생각하면 곱셈이 가능한 행렬이라면 반드시 곱했을 때 자기 자신이 되는 항등원이 존재함

		그게 바로 이 단위 행렬,
		정확히는 행과 열의 개수가 같고 행 번호와 열 번호가 같은 부분은 1, 나머지는 전부 0인 행렬

		위 함수는 그 중에서도 DX에서 사용하는 4x4 행렬에 대한 단위 행렬을 반환하는 함수
		*/
        /*
          행렬의 곱셈 방식 :

          두 행렬 A, B를 곱한다 하면
          A의 모든 행과 B의 모든 열의 값을 다음과 같이 계산
             A         B
          [ 1 2 3 ]   [ 1 1 1 ]
          [ 1 2 3 ]   [ 3 2 1 ]
          [ 1 2 3 ]   [ 5 3 1 ]

          위 2개의 행렬은 각각 다음과 같이 계산함
                            A * B
          [ 1*1 + 2*3 + 3*5 , 1*1 + 2*2 + 3*3, 1*1 + 2*1 + 3*1 ]
          [ 1*1 + 2*3 + 3*5 , 1*1 + 2*2 + 3*3, 1*1 + 2*1 + 3*1 ]
          [ 1*1 + 2*3 + 3*5 , 1*1 + 2*2 + 3*3, 1*1 + 2*1 + 3*1 ]

          [ 22, 14, 6 ]
          [ 22, 14, 6 ]
          [ 22, 14, 6 ]

          이런 행렬끼리의 계산 역시 연산 중 하나이므로
          "어떤 함수에 곱해도 항상 그 함수 원본이 그대로 유지되는, 곱셈의 항등원"이 존재함
          이를 "단위 행렬"이라 부름
          -> 행의 번호와 열의 번호가 동일한 모든 칸이 1이고, 나머지 모든 칸이 0인 행렬
          [ 1, 0, 0 ]
          [ 0, 1, 0 ]
          [ 0, 0, 1 ]

          덤으로 저게 왜 항등원인지 보면

          [ 1, 2, 3 ]
          [ 4, 5, 6 ]에 위의 단위행렬을 곱하면
          [ 7, 8, 9 ]

          [ 1*1 + 2*0 + 3*0, 1*0 + 2*1 + 3*0, ...]
          [ 4*1 + 5*0 + 6*0, 4*0 + 5*1 + 6*0, ...]
          [... ]

          ->
          [ 1, 2, 3 ]
          [ 4, 5, 6 ]
          [ 7, 8, 9 ]

          마지막으로, DX에서는 기본적으로 4X4 행렬만을 사용하기 때문에
          XMMatrixIdentity 함수에선 4X4 크기의 단위행렬만을 제공함

      */
	}

	void Set(Matrix value)
	// 입력받은 행렬을 이 버퍼의 데이터로서 저장하는 함수
	{
		data.matrix = XMMatrixTranspose(value);
		// 행렬 전용 복사함수
	}
};

class ColourBuffer : public ConstBuffer
// 오브젝트가 어떤 색을 가지고 있을지를 기록하는 상수 버퍼
{
public:
	struct Data
	{
		Float4 colour;
	} data;

	ColourBuffer() : ConstBuffer(&data, sizeof(data))
	{
		data.colour = Float4(1.0f, 1.0f, 1.0f, 1.0f);
		// 초기값은 흰색을 지정하는 실수 4개의 집합
	}
};