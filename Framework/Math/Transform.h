#pragma once
class Transform
/*
Transform(트랜스폼) : 컴퓨터 그래픽에서 한 오브젝트를 관리하는 기본 단위
그래픽을 그리기 위한 기본 단위로 이용되는 폴리곤과는 전혀 다른 별개의 개념으로,
폴리곤이 오브젝트라는 개념을 출력하는데 이용되는 단위라면
트랜스폼은 오브젝트라는 개념의 정보를 저장해두는 기본 원소

프로그램에서 객체(인스턴스)라고 부르는 개념을 3D 공간에서 하나의 오브젝트로 만들 때
그 물체가 3D 공간에서 반드시 가지고 있을 좌표 / 크기 / 회전도 등을 인스턴스에 등록해서
그 인스턴스가 알아서 자신을 출력하는 데 사용할 각 정점을 스스로 정의하는 식으로 구성함
트랜스폼은 바로 그 좌표, 크기, 회전도 등을 저장하고 관리하는 기본 묶음집을 칭하는 개념
-> 오브젝트를 표현하기 위해 반드시 하나씩은 가지고 있는 심장 내지 쐐기

앞으로 우리는 DX로 무언가를 만들 때 3D 공간에서 각 오브젝트가 어느 위치, 어느 방향으로 어느 크기를 가지고 있는지
SRT 변환 및 WVP 변환 이론을 통해 구성된 이 트랜스폼을 이용해 관리할 예정

*/
{
// 본 클래스는 다른 오브젝트를 만들 때 상속해서 사용할 클래스이므로 protected를 이용
protected:
	Matrix world;
	// 이 오브젝트(=트랜스폼)가 속한 월드를 기록하는 행렬
	// 오브젝트를 다룰 때 어디를 기준점으로 할 것인지를 행렬의 형태로 저장해
	// 이를 추후 셰이더의 월드 변환에 사용하도록 넘기는 역할

	MatrixBuffer* WB; // 위의 월드 행렬을 저장해서 셰이더에 넘길 때 사용할 상수버퍼

	Vector2 pivot;
	// 이 오브젝트가 어떤 하나의 점을 기준으로 삼아야 할 경우,
	// 그 때 원점으로서 사용할 점을 기록하는 2차원 벡터
	
	// 우리의 팔을 예시로 들면, 전체 3D 공간 상에서 회전을 표현하려 할 경우
	// 각각의 부분이 정확히 어디에서 어디로 이동했는지 등을 연속으로 연산해야 하니 복잡하지만
	// 어깨를 기준으로 할 경우 몇 도 돌았다 정도로만 써도 충분히 표현이 가능하여
	// 더 간단히 표기할 수 있으므로, 그렇게 사용할 추가적인 원점

	Matrix* parent; // 이 오브젝트가 다른 오브젝트에 그 위치 등을 의존하고 있을 경우
	// 사용하는 행렬 -> 그 다른 오브젝트의 월드 행렬을 저장하는 용도

	Matrix S, R, T, P, IP; // SRT 행렬 변환에 사용될 변환 행렬들을 저장할 멤버
	// P와 IP는 위의 pivot을 통해 추가로 만드는 행렬으로 피벗을 이용할 경우에 쓰게 되는 행렬

	XMFLOAT4X4 mat_world; // world 행렬을 XMFLOAT4 형태로 저장하는 멤버
	// SRT 변환 자체엔 필요없는 내용이지만, DX에서 사용하는 몇몇 함수에서 이 자료형을 요구하기에
	// 그 함수들을 쓰기 편하게 미리 멤버로 만든 것

	Vector2 global_scale; // 이 오브젝트가 실제 그래픽상에서 적용되고 있는 scale의 값을 저장할 멤버

	Vector2 right;
	Vector2 up;
	// Transform이 현재 보고 있는 방향을 정의하는 벡터
	// 각각 이 트랜스폼이 현재 보고 있는 방향을 기준으로 어느 방향이 오른쪽/위쪽인지
	// 이 벡터에 단위벡터로서 저장

public:
	bool is_active;
	// 프로그램 상에서 인스턴스를 매번 사용할 때마다 만들고 제거하고 하는 것은 
	// 심한 리소스 낭비를 가져오므로,
	// 기본적으로는 게임을 진행하기 전에 필요한 만큼 그런 인스턴스들을 생성해두는 식으로
	// 로딩 작업을 거치고, 그렇게 만들어진 인스턴스를 상황에 따라 활성화/비활성화하여 관리하는데
	// 그 때 사용할 "이 오브젝트의 활성화 여부"를 저장하는 bool 플래그

	Vector2 pos; // 이 Transform이 위치한 좌표
	Vector2 scale; // 이 Transform의 크기를 결정할 변수
	Float3 rot; // 이 Transform이 x/y/z축 각각 얼마나 회전해있는지를 저장하는 변수
	// 일단 3차원으로 만들어두긴 했으나, 이는 DX의 각종 함수들과 호환시키기 위해 만든 것으로
	// 실제(=2D)로는 이 rot의 값 중 z값 = z축의 회전각도만 이용할 것

	Transform(Vector2 p = Vector2(0, 0), Vector2 s = Vector2(1, 1), float a = 0,
		Matrix* parent = NULL);
	~Transform();

	float GetAngle() { return rot.z; } // 이 오브젝트의 회전각을 반환하는 함수
	// 지금은 관련 변수가 public이어서 직접 접근할 수 있긴 하지만,
	// 나중에는 이 값들이 private가 될 수 있기도 하고
	// 2D에 한해서는 다른 값들과는 달리 rot.z만 이용하기도 하므로 혼동의 여지를 줄이기 위해,
	// 혹은 우리가 항시 0으로 고정해야 할 rot.x나 rot.y에 실수로 접근할 여지를 줄이기 위해
	// 일부러 이 함수를 통해 접근하는 것
	void SetAngle(float a) { rot.z = a; }

	void SetActive(bool active) { is_active = active; }
	bool GetActive() { return is_active; }
	// 이것 역시 is_active가 public이기 때문에 꼭 필요한 건 아니나
	// 원한다면 이 역시 private(혹은 protected)로 삼을 수 있으므로 접근자와 지정자를 만들어줌

	void SetParent(Matrix* parent) { this->parent = parent; }
	// 이 오브젝트가 어느 오브젝트의 위치에 귀속되어있는지를 재설정해주는 지정자
	// WorldUpdate에서 매개변수로 받을 경우 항상 입력해야만 정상 작동하기 때문에,
	// 그런 불편을 제거하고자 분리

	void WorldUpdate();
	// 오브젝트를 프로그램 상에서 업데이트하는 동안
	// 오브젝트의 각종 패러미터는 항상 변하기 마련
	// 그렇게 변한 패러미터를 월드 행렬에 반영시키기 위해 항상 업데이트 후 실행시켜줘야 하는
	// SRT 변환 행렬을 구하는 함수

	Matrix* GetWorld() { return &world; }
	// 이 트랜스폼의 월드 행렬을 트랜스폼 외부에서 사용해야 하는 경우가 많기 때문에,
	// 접근 가능한 경로를 만들어둠
	Vector2 GlobalPos() // 실제 그래픽 상에서의 표기 좌표를 반환하는 함수
	{
		return Vector2(mat_world._41, mat_world._42);
		// 업데이트 후 최종적으로 구성된 4X4 월드 행렬에서
		// T 변환에 사용되었던 데이터만 가져와 변환

		// WorldUpdate에서 설명하겠지만,
		// 부모 오브젝트 등을 기준으로 이 오브젝트의 좌표가 정해지는 경우
		// 이 트랜스폼이 가지고 있는 좌표 등의 정보와
		// 실제 화면에서 이 오브젝트가 위치하는 좌표의 정보가 일치하지 않는 경우가 대부분
		// 그래서 이 오브젝트가 실제 화면에서 출력될 때 어느 좌표에 위치하는지
		// 실제로 출력을 위해 기록된 월드 행렬에서 추출해와 반환한 것
	}
	Vector2 GlobalScale() // 위와 마찬가지로 실제 그래픽 상에서 적용되고 있는 Scale()을 반환
	{
		return global_scale;
	}

	// Transform이 현재 보는 방향을 기준으로 상하좌우를 확인해 반환하는 함수
	Vector2 Right() { return right.Normalized(); }
	Vector2   Left() { return right.Normalized() * -1.0f; }
	Vector2 Up() { return up.Normalized(); }
	Vector2 Down() { return up.Normalized() * -1.0f; }
};